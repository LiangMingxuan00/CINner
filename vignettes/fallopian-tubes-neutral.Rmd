---
title: "Simulations for neutral evolution in the Fallopian tubes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulations for neutral evolution in the Fallopian tubes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning=FALSE, message=FALSE,
  comment = "#>"
)
```

```{r setup}
library(ggplot2)
library(signals)
library(CancerSimulator)
```

```{r setup}
devtools::load_all()
devtools::document()
```

## Background
This vignette illustates how to use the program to create simulations for a model.
First we install the simulator...


## Set up the model
For this example, we simulate the neutral evolution of epithelial cells in the Fallupian tubes. We will look at the assumptions of the model.

The program automatically uses variables input from four files, names in the following fashion:

`MODEL-input-cancer-genes.csv`
`MODEL-input-copy-number-blocks.csv`
`MODEL-input-population-dynamics.csv`
`MODEL-input-variables.csv`

where `MODEL` is the prefix for the model name.

```{r}
MODEL <- 'FALLOPIAN-TUBES-NEUTRAL'
SIMULATOR_VARIABLES_for_simulation(MODEL)
```

The total cell count will follow the input dynamics:

```{r, fig.height=4 , fig.width=10}
vec_time          <- (T_start_time:100:T_end_time)/365
vec_population    <- func_expected_population(vec_time*365)
df                <- data.frame(vec_time,vec_population)

ggplot(df,aes(vec_time)) +
      geom_line(aes(y=vec_population),colour="red") +
      xlim(vec_time[1],vec_time[length(vec_time)]) +
      xlab('Age') +
      ylab('Cell count') +
      ggtitle("Expected dynamics of total cell count")
```

Each simulation follows the evolution starting from one normal cell at `age_birth` until `age_end`, following the expected total cell count dynamics above. `cell_lifespan` gives the expected lifespan for any cell in the population. At `age_end`, the program samples `N_sample` cells from the population and derives mutational and CN information.

The program uses the tau-leaping algorithm to speed up, for which `T_tau_step` is the fixed time-step (smaller `T_tau_step` means better convergence to the traditional Gillespie's algorithm, but longer runtime).

```{r}
cat('age_birth                                                    = ',age_birth,'(years)\n')
cat('age_end                                                      = ',age_end,'(years)\n')
cat('cell_lifespan                                                = ',cell_lifespan,'(days)\n')
cat('N_sample                                                     = ',N_sample,'(years)\n')
cat('T_tau_step                                                   = ',T_tau_step,'(days)\n')
```

For this model, we do not include driver genes and selection:

```{r}
cat('Poisson rate of new driver mutations                         = ',rate_driver,'\n')

```

The following variables dictate the probability of each CN event type during a cell division. Because there is no driver genes and selection, the CN events will always be neutral.

```{r}
cat('Probability of WGD                                           = ',prob_CN_whole_genome_duplication,'\n')
cat('Probability of chromosome missegragation                     = ',prob_CN_missegregation,'\n')
cat('Probability of chromosome-arm missegragation                 = ',prob_CN_chrom_arm_missegregation,'\n')
cat('Probability of focal amplification                           = ',prob_CN_focal_amplification,'\n')
cat('Probability of focal deletion                                = ',prob_CN_focal_deletion,'\n')
```

The focal amplification/deletion events require additional parameters for the mean length of each event:

```{r}
cat('Geometric parameter for bin length of a focal amplification  = ',prob_CN_focal_amplified_length,'\n')
cat('Geometric parameter for bin length of a focal deletion       = ',prob_CN_focal_deletion_length,'\n')
```

The length of each chromosome is computed in bin counts:

```{r, fig.height=4 , fig.width=10}
barplot(vec_CN_block_no,main="Count of CN bins in each chromosome",xlab="Chromosome",names.arg=c(1:N_chromosomes))
```

Similarly, the centromere location of each chromosome is also computed in bin counts:

```{r, fig.height=4 , fig.width=10}
barplot(vec_centromere_location,main="Centromere location of each chromosome",xlab="Chromosome",names.arg=c(1:N_chromosomes))
```

## Create and inspect one simulation
Function `SIMULATOR_FULL_PROGRAM_one_simulation` outputs one simulation for the model. The parameter `stage_final` decides where to stop the simulation:
- `stage_final`=1 outputs the evolution at the clonal level

```{r}
stage_final                   <- 1
package_output                <- SIMULATOR_FULL_PROGRAM_one_simulation(MODEL,stage_final)
package_clonal_evolution      <- package_output[[1]]
```

We first inspect the dynamics of the total cell population.

```{r, fig.height=4 , fig.width=10}
vec_time                      <- package_clonal_evolution[[13]]
vec_clonal_populations        <- package_clonal_evolution[[16]]

vec_total_population          <- c()
for (i in 1:length(vec_time)){
      vec_total_population[i] <- sum(vec_clonal_populations[[i]])
}

vec_time_plot                 <- vec_time[seq(from=1,to=length(vec_time),by=100)]/365
vec_cell_count_sim_plot       <- vec_total_population[seq(from=1,to=length(vec_time),by=100)]
vec_cell_count_exp_plot       <- func_expected_population(365*vec_time_plot)
df                            <- data.frame(vec_time_plot,vec_cell_count_sim_plot,vec_cell_count_exp_plot)

ggplot(df,aes(vec_time_plot)) +
      geom_line(aes(y=vec_cell_count_exp_plot),colour="red") +
      geom_point(aes(y=vec_cell_count_sim_plot),colour="blue") +
      xlim(vec_time_plot[1],vec_time_plot[length(vec_time_plot)]) +
      xlab('Age') +
      ylab('Cell count') +
      ggtitle("Expected (red line) vs Simulated (blue dots) dynamics of total cell count")
```

TO BE CONTINUED: exploring the CN structure of the final population














```{r}

# head(ascn_min)
# cl_min      <- umap_clustering(ascn_min)
# plotHeatmap(ascn_min,plotcol="state",clusters=cl_min$clustering,tree=cl_min$tree,reorderclusters=TRUE,plottree=FALSE)
# plotHeatmap(ascn_min,plotcol="Min",clusters=cl_min$clustering,tree=cl_min$tree,reorderclusters=TRUE,plottree=FALSE)

```

















## Create multiple simulations
We can create multiple simulations for the same model with function `TEST_SIMULATIONS_FOR_FIRST_MANUSCRIPT`. The parameter `N_simulations` dictates how many simulations are created.

```{r}
stage_final                   <- 1
N_simulations                 <- 10
output                        <- TEST_SIMULATIONS_FOR_FIRST_MANUSCRIPT(MODEL,stage_final,N_simulations)
# package_clonal_evolution      <- package_output[[1]]
```

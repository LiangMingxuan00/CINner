---
title: "How to use Cancer Simulator"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use Cancer Simulator}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning=FALSE, message=FALSE,
  comment = "#>"
)
```

```{r setup}
devtools::install_github("dinhngockhanh/CancerSimulator")


library(ggplot2)
library(signals)
library(dendextend)
library(fishplot)

library(CancerSimulator)

devtools::load_all()
devtools::document()
```

# Set up model variables

Cancer Simulator requires several csv files containing variables to set up the simulations. Here we detail how to easily build these files.

## General variables for every cell

The first step is to specify the variables describing every cell during the process. The cells are assumed to have the same expected lifespan (regardless of their driver or CN profiles). The cell lifespan is always in days.

```{r}
cell_lifespan                       <- 7
```

Next, we specify the times at the beginning and the end of the simulation. The unit can be `day`, `week`, `month` or `year`.

```{r}
T_0                                 <- list(0,'year')
T_end                               <- list(80,'year')
```

We will sample 200 cells from the population at `T_end`:

```{r}
N_sample                            <- 200
```

We use the tau-leaping algorithm to simulate the clonal evolution. This requires a time step. The smaller this step is, the closer the resulting simulation is to the traditional Gillespie's algorithm, but it also means increasing runtime. By default, we use tau = 3 days.

```{r}
T_tau_step                          <- 3
```

An important variable is the size of CN bins. By default, this will be 500,000 bp.

```{r}
CN_bin_length                       <- 500000
```

We have to set up the probability that each class of CN events occurs in a cell division. The local events (chromosome, chromosome-arm or focal level), if happening, will occur on a random location among eligible places.

```{r}
prob_CN_whole_genome_duplication    <- 1e-6
prob_CN_missegregation              <- 1e-6
prob_CN_chrom_arm_missegregation    <- 1e-6
prob_CN_focal_amplification         <- 1e-6
prob_CN_focal_deletion              <- 1e-6
prob_CN_cnloh_interstitial          <- 1e-6
prob_CN_cnloh_terminal              <- 1e-6
```

The focal and CNLOH events require the geometric parameters for the length (in bin count) of the DNA region being affected.

```{r}
prob_CN_focal_amplification_length  <- 0.1
prob_CN_focal_deletion_length       <- 0.1
prob_CN_cnloh_interstitial_length   <- 0.1
prob_CN_cnloh_terminal_length       <- 0.1
```

Next, we set up the mutation rates for drivers and passengers, per bp per cell division.

```{r}
rate_driver                         <- 1e-16
rate_passenger                      <- 1e-11
```

We can also set up the upper limits for the driver count and local CN for a cell to still be viable.

```{r}
bound_driver                        <- 3
bound_ploidy                        <- 20
```

Finally, we need to set up the growth model for the total cell population. The algorithm is designed to follow any dynamics (within the limit imposed by how fast the cells can divide, defined by their lifespan). Note that to avoid cases where the simulations are terminated prematurely because of the stochasticity, the population size should not decrease to below about 10 cells at any time.

We build one vector for the time points (in the same unit as `T_0` and `T_end`, therefore in years in this case), and another vector for the corresponding expected population sizes. As an example, we use the logistic function.

```{r}
vec_time                            <- T_0[[1]]:T_end[[1]]
L                                   <- 10000
t_0                                 <- 20
k                                   <- 0.3
vec_cell_count                      <- L/(1+exp(-k*(vec_time-t_0)))
table_population_dynamics           <- cbind(vec_time,vec_cell_count)
```

Finally, we build the model variable files, using function `BUILD_general_variables`:

```{r}
MODEL_VARIABLES   <- BUILD_general_variables(cell_lifespan=cell_lifespan,
                        T_0=T_0,
                        T_end=T_end,
                        N_sample=N_sample,
                        T_tau_step=T_tau_step,
                        CN_bin_length=CN_bin_length,
                        prob_CN_whole_genome_duplication=prob_CN_whole_genome_duplication,
                        prob_CN_missegregation=prob_CN_missegregation,
                        prob_CN_chrom_arm_missegregation=prob_CN_chrom_arm_missegregation,
                        prob_CN_focal_amplification=prob_CN_focal_amplification,
                        prob_CN_focal_deletion=prob_CN_focal_deletion,
                        prob_CN_cnloh_interstitial=prob_CN_cnloh_interstitial,
                        prob_CN_cnloh_terminal=prob_CN_cnloh_terminal,
                        prob_CN_focal_amplification_length=prob_CN_focal_amplification_length,
                        prob_CN_focal_deletion_length=prob_CN_focal_deletion_length,
                        prob_CN_cnloh_interstitial_length=prob_CN_cnloh_interstitial_length,
                        prob_CN_cnloh_terminal_length=prob_CN_cnloh_terminal_length,
                        rate_driver=rate_driver,
                        rate_passenger=rate_passenger,
                        bound_driver=bound_driver,
                        bound_ploidy=bound_ploidy,
                        table_population_dynamics=table_population_dynamics)
```

## Driver library

We first define a list of drivers to include in the model:

```{r}
vec_driver_genes  <- c('TP53','BRCA1','BRCA2','MSH2','MSH6','ARID1A',
                       'STK11','BRAF','MLH1','PIK3R1','ERBB2','CTNNB1',
                       'AKT1','PPP2R1A')
```

For each driver, we need to decide if it behaves as a TSG or an oncogene. Note that the algorithm requires at least one gene of each type to behave properly.

```{r}
vec_driver_role   <- c('TSG','TSG','TSG','TSG','TSG','TSG',
                       'TSG','ONCOGENE','TSG','TSG','ONCOGENE','ONCOGENE',
                       'ONCOGENE','TSG')
```

We then give each driver a selective strength. The higher it is, the more likely the mutated cell will escape death and the faster it reaches fixation.

```{r}
vec_driver_s      <- c(0.01,0.01,0.01,0.01,0.01,0.01,
                       0.01,0.01,0.01,0.01,0.01,0.01,
                       0.01,0.01)
```

The function `BUILD_driver_library` builds the driver library. If the chromosome and bin locations of the drivers are not given, the function will find them by crosschecking with the Cancer Gene Census database.

```{r}
MODEL_VARIABLES   <- BUILD_driver_library(MODEL_VARIABLES=MODEL_VARIABLES,
                                          vec_driver_genes=vec_driver_genes,
                                          vec_driver_role=vec_driver_role,
                                          vec_driver_s=vec_driver_s)
```

## Initial cell population

Assume we have 20 cells at `T_0`, which come from 2 different clones. We will declare the specifics of each clone.

### Normal diploid cells

Let's start by declaring the clone for the first 10 cells. `cell_count` tells the algorithm how many cells there are in this clone at `T_0`.

```{r}
cell_count        <- 10
```

`CN_arm` is a matrix of the baseline allele specification for each arm of each strand. A strand having `B-B` tells the algorithm that it has allele B everywhere.

```{r}
CN_strand_1       <- c(rep('A-A',length=23),'')
CN_strand_2       <- c(rep('B-B',length=23),'')
CN_arm            <- cbind(CN_strand_1,CN_strand_2)
print(CN_arm)
```

`CN_focal` overrides `CN_arm` if there are local CN events. As there is no abnormal CN, this is empty.

```{r}
CN_focal          <- list()
```

Finally, `drivers` lists the mutated drivers, also empty for this clone.

```{r}
drivers           <- list()
```

We use the function `BUILD_initial_population` to add this clone to the initial cell population.

```{r}
MODEL_VARIABLES   <- BUILD_initial_population(MODEL_VARIABLES=MODEL_VARIABLES,
                                          cell_count=cell_count,
                                          CN_arm=CN_arm,
                                          CN_focal=CN_focal,
                                          drivers=drivers)
```

### Clone with WGD and mutated TP53 activated via CN-LOH

The second clone contains 10 cells, and it has undergone the driver and CN events in order:

1. Gain TP53 mutation on strand B
2. Terminal CN-LOH on chromosome 17 from bin 1 to bin 20
3. Whole-genome duplication

Again, we declare the clone's population at `T_0`:

```{r}
cell_count        <- 5
```

Because of WGD, there are two strands A and two strands B of each chromosome:

```{r}
CN_strand_1       <- c(rep('A-A',length=23),'')
CN_strand_2       <- c(rep('B-B',length=23),'')
CN_strand_3       <- c(rep('B-B',length=23),'')
CN_strand_4       <- c(rep('B-B',length=23),'')
CN_arm            <- cbind(CN_strand_1,CN_strand_2,CN_strand_3,CN_strand_4)
print(CN_arm)
```

Except on chromosome 17. Since the CN-LOH event happens before WGD, the region on all strands should be replaced with the B allele.

```{r}
CN_focal          <- list(    list(chromosome=17,strand=1,bin_start=1,bin_end=20,allele='B'),
                              list(chromosome=17,strand=2,bin_start=1,bin_end=20,allele='B'),
                              list(chromosome=17,strand=3,bin_start=1,bin_end=20,allele='B'),
                              list(chromosome=17,strand=4,bin_start=1,bin_end=20,allele='B'))
```

Finally, there should be mutated TP53 on all strands of chromosome 17:

```{r}
drivers           <- list(    list(strand=1,unit=1,driver='TP53'),
                              list(strand=2,unit=1,driver='TP53'),
                              list(strand=3,unit=1,driver='TP53'),
                              list(strand=4,unit=1,driver='TP53'))
```

```{r}
MODEL_VARIABLES   <- BUILD_initial_population(MODEL_VARIABLES=MODEL_VARIABLES,
                                          cell_count=cell_count,
                                          CN_arm=CN_arm,
                                          CN_focal=CN_focal,
                                          drivers=drivers)
```

## Save the input files

The last step is to save the model variable files.

Let's give a name to the model.

```{r}
MODEL_NAME        <- 'EXPERIMENT-1A'
```

```{r}
SAVE_model_variables(MODEL_NAME=MODEL_NAME,MODEL_VARIABLES=MODEL_VARIABLES)
```







```{r}
print(MODEL_VARIABLES$general_variables)

print(MODEL_VARIABLES$cn_info)

print(MODEL_VARIABLES$population_dynamics)

print(MODEL_VARIABLES$driver_library)

print(MODEL_VARIABLES$initial_cn)

print(MODEL_VARIABLES$initial_others)
```

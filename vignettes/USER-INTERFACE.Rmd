---
title: "How to use Cancer Simulator"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use Cancer Simulator}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning=FALSE, message=FALSE,
  comment = "#>"
)
```

```{r setup}
devtools::install_github("dinhngockhanh/CancerSimulator")


library(ggplot2)
library(signals)
library(dendextend)
library(fishplot)

library(CancerSimulator)

devtools::load_all()
devtools::document()
```

# Set up model variables

Cancer Simulator requires several csv files containing variables to set up the simulations. Here we detail how to easily build these files.

Let's give a name to the model.

```{r}
MODEL                               <- 'EXPERIMENT-1'
```

## General variables for every cell

The first step is to specify the variables describing every cell during the process. The cells are assumed to have the same expected lifespan (regardless of their driver or CN profiles). The cell lifespan is always in days.

```{r}
cell_lifespan                       <- 7
```

Next, we specify the times at the beginning and the end of the simulation. The unit can be `day`, `week`, `month` or `year`.

```{r}
T_0                                 <- list(0,'year')
T_end                               <- list(80,'year')
```

We use the tau-leaping algorithm to simulate the clonal evolution. This requires a time step. The smaller this step is, the closer the resulting simulation is to the traditional Gillespie's algorithm, but it also means increasing runtime. By default, we use tau = 3 days.

```{r}
T_tau_step                          <- 3
```

An important variable is the size of CN bins. By default, this will be 500,000 bp.

```{r}
CN_bin_length                       <- 500000
```

We have to set up the probability that each class of CN events occurs in a cell division. The local events (chromosome, chromosome-arm or focal level), if happening, will occur on a random location among eligible places.

```{r}
prob_CN_whole_genome_duplication    <- 1e-6
prob_CN_missegregation              <- 1e-6
prob_CN_chrom_arm_missegregation    <- 1e-6
prob_CN_focal_amplification         <- 1e-6
prob_CN_focal_deletion              <- 1e-6
prob_CN_cnloh_interstitial          <- 1e-6
prob_CN_cnloh_terminal              <- 1e-6
```

The focal and CNLOH events require the geometric parameters for the length (in bin count) of the DNA region being affected.

```{r}
prob_CN_focal_amplification_length  <- 0.1
prob_CN_focal_deletion_length       <- 0.1
prob_CN_cnloh_interstitial_length   <- 0.1
prob_CN_cnloh_terminal_length       <- 0.1
```

Next, we set up the mutation rates for drivers and passengers, per bp per cell division.

```{r}
rate_driver                         <- 1e-16
rate_passenger                      <- 1e-11
```

We can also set up the upper limits for the driver count and local CN for a cell to still be viable.

```{r}
bound_driver                        <- 3
bound_ploidy                        <- 20
```

Finally, we need to set up the growth model for the total cell population. The algorithm is designed to follow any dynamics (within the limit imposed by how fast the cells can divide, defined by their lifespan). Note that to avoid cases where the simulations are terminated prematurely because of the stochasticity, the population size should not decrease to below about 10 cells at any time.

We build one vector for the time points (in the same unit as `T_0` and `T_end`, therefore in years in this case), and another vector for the corresponding expected population sizes. As an example, we use the logistic function.

```{r}
vec_time                            <- T_0[[1]]:T_end[[1]]
L                                   <- 10000
t_0                                 <- 20
k                                   <- 0.3
vec_cell_count                      <- L/(1+exp(-k*(vec_time-t_0)))
table_population_dynamics           <- cbind(vec_time,vec_cell_count)
```

Finally, we build the model variable files, using function `BUILD_general_variables`:

```{r}
MODEL_VARIABLES   <- BUILD_general_variables(cell_lifespan=cell_lifespan,
                        T_0=T_0,
                        T_end=T_end,
                        T_tau_step=T_tau_step,
                        CN_bin_length=CN_bin_length,
                        prob_CN_whole_genome_duplication=prob_CN_whole_genome_duplication,
                        prob_CN_missegregation=prob_CN_missegregation,
                        prob_CN_chrom_arm_missegregation=prob_CN_chrom_arm_missegregation,
                        prob_CN_focal_amplification=prob_CN_focal_amplification,
                        prob_CN_focal_deletion=prob_CN_focal_deletion,
                        prob_CN_cnloh_interstitial=prob_CN_cnloh_interstitial,
                        prob_CN_cnloh_terminal=prob_CN_cnloh_terminal,
                        prob_CN_focal_amplification_length=prob_CN_focal_amplification_length,
                        prob_CN_focal_deletion_length=prob_CN_focal_deletion_length,
                        prob_CN_cnloh_interstitial_length=prob_CN_cnloh_interstitial_length,
                        prob_CN_cnloh_terminal_length=prob_CN_cnloh_terminal_length,
                        rate_driver=rate_driver,
                        rate_passenger=rate_passenger,
                        bound_driver=bound_driver,
                        bound_ploidy=bound_ploidy,
                        table_population_dynamics=table_population_dynamics)
```

## Driver library

We first define a list of drivers to include in the model:

```{r}
vec_driver_genes  <- c('TP53','BRCA1','BRCA2','MSH2','MSH6','ARID1A',
                       'STK11','BRAF','MLH1','PIK3R1','ERBB2','CTNNB1',
                       'AKT1','PPP2R1A')
```

For each driver, we need to decide if it behaves as a TSG or an oncogene. Note that the algorithm requires at least one gene of each type to behave properly.

```{r}
vec_driver_role   <- c('TSG','TSG','TSG','TSG','TSG','TSG',
                       'TSG','ONCOGENE','TSG','TSG','ONCOGENE','ONCOGENE',
                       'ONCOGENE','TSG')
```

We then give each driver a selective strength. The higher it is, the more likely the mutated cell will escape death and the faster it reaches fixation.

```{r}
vec_driver_s      <- c(0.01,0.01,0.01,0.01,0.01,0.01,
                       0.01,0.01,0.01,0.01,0.01,0.01,
                       0.01,0.01)
```

The function `BUILD_driver_library` builds the driver library. If the chromosome and bin locations of the drivers are not given, the function will find them by crosschecking with the Cancer Gene Census database.

```{r}
MODEL_VARIABLES   <- BUILD_driver_library(MODEL_VARIABLES=MODEL_VARIABLES,
                                          vec_driver_genes=vec_driver_genes,
                                          vec_driver_role=vec_driver_role,
                                          vec_driver_s=vec_driver_s)
```

## Initial cell population

Assume we have 20 cells at `T_0`. We can link the cells to clones sharing the same driver and CN profile. There are four variables describing each clone. `cell_count` is the number of cells in this clone at `T_0`. `CN_arm` gives the baseline allele specifics of each chromosome arm. `CN_focal` overrides the baseline with specific bins' abnormal alleles (if any). Finally, `drivers` lists the mutated drivers to be placed on the genome.

Let's start with having 10 cells with normal female diploid genotype. There would be two strands of each chromosome (strand `A` and strand `B`) from chromosome 1 to X, and no chromosome Y.

```{r}
cell_count        <- 10
CN_arm            <- c(rep('AB',46),rep('',2))
CN_focal          <- c()
drivers           <- ''

MODEL_VARIABLES   <- BUILD_initial_population(MODEL_VARIABLES=MODEL_VARIABLES,
                                          cell_count=cell_count,
                                          CN_arm=CN_arm,
                                          drivers=drivers)
```

The second clone contains 5 cells, and









```{r}
print(MODEL_VARIABLES$general_variables)

print(MODEL_VARIABLES$cn_info)

print(MODEL_VARIABLES$population_dynamics)

print(MODEL_VARIABLES$driver_library)

print(MODEL_VARIABLES$initial_cn)

print(MODEL_VARIABLES$initial_others)
```

---
title: "An introduction to Cancer Simulator"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to Cancer Simulator}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE, message = FALSE,
  comment = "#>"
)
```

The library can be installed by running the following line: (this only needs to be performed once)

```{r setup}
devtools::install_github("dinhngockhanh/CancerSimulator")
```

We can then use the library:

```{r}
library(CancerSimulator)
```

# Set up model variables

CancerSimulator requires many input parameters about the assumed characteristics of cancer growth. One easy method to load the parameters is by creating `model_variables`, which is a list containing relevant variables in a specific order, then using function `SAVE_model_variables` to save them as csv files that can be read in the next sections when the simulator is called. Here we detail how to create and the parameter list.

## General variables for every cell

We first specify the cell lifespan (always in days). This is the mean of the exponentially distributed lifetime of every cell during cancer evolution, regardless of their driver mutation or CN profiles.

```{r}
cell_lifespan <- 30
```

Next, we specify the time points at the beginning and the end of the simulation. The unit can be `day`, `week` (= 7 days), `month` (= 30 days) or `year` (= 365 days). The unit should be the same for both time points.

```{r}
T_0 <- list(0, "year")
T_end <- list(80, "year")
```

Next variables dictate the time points that each sample is taken (same unit as the beginning and end time points), how many cells are in each sample, and the unique ID for each sample.

```{r}
Table_sample <- data.frame(Sample_ID = "SA01", Cell_count = 300, Age_sample = 80)
```

The simulator's efficiency is based partially on its use of the tau-leaping algorithm, which simulates the evolution in fixed steps instead of the exact Gillespie algorithm. As such, it requires a suggested time step. If not specified, the time step is automatically set to be half the cell lifespan. For statistical accuracy, it should not be higher. However, setting significantly low numbers for time step will lead to increased simulation run time.

```{r}
T_tau_step <- cell_lifespan / 2
```

To speed up the simulations and in accordance with the current state of single-cell DNA sequencing, the genome is divided into bins of equal lengths. Here we specify the length of each bin, understood in number of base pairs.

```{r}
CN_bin_length <- 500000
```

Three selection models are included in the framework:
- `chrom-arm-selection` models the selection for gains and losses of chromosome arms, depending on their genetic balances.
- `driver-gene-selection` models the selection for gains and losses and mutations of specific driver genes.
- `chrom-arm-and-driver-gene-selection` combines both models into a hybrid model, where cancer is driven both by large-scale genetic imbalance and local events targeting specific genes.

```{r}
selection_model <- "chrom-arm-and-driver-gene-selection"
```

The next variables are the probabilities that each class of CNA events occurs in a cell division. There are three large-scale CNA mechanisms:
- Whole Genome Duplication results in one daughter cell with double the genomic material of the mother cell.
- Missegregation targets a uniformly chosen chromosome strand, which is then gained in one daughter cell and lost in the other.
- The same occurs for chromosome-arm missegregation but only for one of the chromosome's arms with equal probabilities.

The local events target a randomly chosen region in a uniformly chosen chromosome arm in one of the daughter cells. All of these events require additional parameters for the region length distributions, to be discussed next. There are four local CNA mechanisms:
- Focal amplification and deletion duplicate or delete the region, respectively.
- Interstitial and terminal CNLOH replace all alleles within the region across chromosome strands with an allele chosen at random. Interstitial CNLOH can occur anywhere in the arm, but terminal CNLOH has to occur at the chromosome's end.

```{r}
prob_CN_whole_genome_duplication <- 0.5e-4
prob_CN_missegregation <- 2e-4
prob_CN_chrom_arm_missegregation <- 2e-4
prob_CN_focal_amplification <- 0.e-4
prob_CN_focal_deletion <- 2e-4
prob_CN_cnloh_interstitial <- 0e-4
prob_CN_cnloh_terminal <- 0e-4
```

In specific applications, we might also consider neutral versions of the aforementioned CNA mechanisms. These events are assumed to change the CN profiles of the daughter cells without affecting their fitness. The rules dictating how the daughter cells' CN profiles change as a result of neutral CNAs are similar to the selective CNA mechanisms above, including the additional parameters specifying the region length distributions of the local CNA events.

```{r}
prob_neutral_CN_whole_genome_duplication <- 0
prob_neutral_CN_missegregation <- 0
prob_neutral_CN_chrom_arm_missegregation <- 0
prob_neutral_CN_focal_amplification <- 0
prob_neutral_CN_focal_deletion <- 0
prob_neutral_CN_cnloh_interstitial <- 0
prob_neutral_CN_cnloh_terminal <- 0
```

We now specify the parameters for the region length distributions of the local CNA mechanisms. Let `X` be a given local CNA mechanism (`X` = `CN_focal_amplification_length`, `CN_focal_deletion_length`, `CN_cnloh_interstitial_length`, `CN_cnloh_terminal_length`). We choose between two distributions:
- `model_X` = `geom`: the region length is geometrically distributed, with the rate given by another parameter `prob_X` (unit is bin counts). If `model_X` is not specified, then this is the default.
- `model_X` = `beta`: the region length equals a beta distributed ratio of the chosen chromosome arm. This requires two parameters for the beta distribution, given by `prob_X_shape_1` and `prob_X_shape_2`.

```{r}
model_CN_focal_amplification_length <- "beta"
prob_CN_focal_amplification_length_shape_1 <- 0.758304780825031
prob_CN_focal_amplification_length_shape_2 <- 5.33873409782625
model_CN_focal_deletion_length <- "beta"
prob_CN_focal_deletion_length_shape_1 <- 0.814054548726361
prob_CN_focal_deletion_length_shape_2 <- 6.16614890284825
prob_CN_cnloh_interstitial_length <- 0.005
prob_CN_cnloh_terminal_length <- 0.005
```

The rate of driver mutations is per base pair per division. Therefore, cells with more genomic materials, for instance after Whole Genome Duplication, would mutate at increased rates. If a driver mutation occurs, the gene to acquire the new mutation is chosen from an input list of driver genes, excluding the genes already mutated in the cell. A cell's fitness increases with the number of driver mutations it has acquired.

```{r}
rate_driver <- 0
```

The rate of passenger mutations is likewise per base pair per division. However, passenger mutations do not change a cell's fitness.

```{r}
rate_passenger <- 1e-11
```

A cell increases its fitness by acquiring CNAs and driver mutations. However, the cell is above all subject to viability conditions. If it violates any of these conditions, the cell is deemed unviable and its fitness is set to 0, therefore will die:
- `bound_driver` is the upper bound on how many driver mutations the cell has acquired.
- `bound_average_ploidy` is the upper bound on the ploidy (i.e. average CN among all bins) of the cell.
- `bound_maximum_CN` is the upper bound on the CN in any bin in the cell.
- `bound_homozygosity` is the upper bound on the bin count with homozygosity (i.e. bins with CN=0).

```{r}
bound_driver <- 3
bound_average_ploidy <- 4.5
bound_maximum_CN <- 8
bound_homozygosity <- 500
```

The algorithm is designed to follow any dynamics (within the limit imposed by how fast the cells can divide or die, defined by their lifespan). The expected population dynamics is input as two vectors: `vec_cell_count` lists the requested total cell counts at the corresponding time points listed in `vec_time`, and both vectors are combined in variable `table_population_dynamics`. The expected population size in the simulations at any time point is interpolated from the two nearest time points in this variable.

Here, we request a logistic expansion from 20 cells at the beginning time point to 10000 cells at the final time point.

```{r}
vec_time <- T_0[[1]]:T_end[[1]]
vec_cell_count <- 10000 / (1 + exp(-0.3 * (vec_time - 20)))
table_population_dynamics <- cbind(vec_time, vec_cell_count)
```

If noisy readcounts based on the cells' true CN profiles are requested, we need to also set the parameters for the sequencing noise and bias model:

```{r}
gc <- read.csv(file = system.file("extdata", "gc_map_500kb.csv", package = "CancerSimulator"))
gc_slope <- 1.2
gc_int <- 0
sigma1 <- 0.02642392
num_reads <- 3906632
```

Finally, using the function `BUILD_general_variables`, we can build `model_variables`, an R list containing all variables described thus far:

```{r}
model_variables <- BUILD_general_variables(
    cell_lifespan = cell_lifespan,
    T_0 = T_0, T_end = T_end, T_tau_step = T_tau_step,
    Table_sample = Table_sample,
    CN_bin_length = CN_bin_length,
    prob_CN_whole_genome_duplication = prob_CN_whole_genome_duplication,
    prob_CN_missegregation = prob_CN_missegregation,
    prob_CN_chrom_arm_missegregation = prob_CN_chrom_arm_missegregation,
    prob_CN_focal_amplification = prob_CN_focal_amplification,
    prob_CN_focal_deletion = prob_CN_focal_deletion,
    prob_CN_cnloh_interstitial = prob_CN_cnloh_interstitial,
    prob_CN_cnloh_terminal = prob_CN_cnloh_terminal,
    prob_neutral_CN_whole_genome_duplication = prob_neutral_CN_whole_genome_duplication,
    prob_neutral_CN_missegregation = prob_neutral_CN_missegregation,
    prob_neutral_CN_chrom_arm_missegregation = prob_neutral_CN_chrom_arm_missegregation,
    prob_neutral_CN_focal_amplification = prob_neutral_CN_focal_amplification,
    prob_neutral_CN_focal_deletion = prob_neutral_CN_focal_deletion,
    prob_neutral_CN_cnloh_interstitial = prob_neutral_CN_cnloh_interstitial,
    prob_neutral_CN_cnloh_terminal = prob_neutral_CN_cnloh_terminal,
    model_CN_focal_amplification_length = model_CN_focal_amplification_length,
    model_CN_focal_deletion_length = model_CN_focal_deletion_length,
    prob_CN_focal_amplification_length_shape_1 = prob_CN_focal_amplification_length_shape_1,
    prob_CN_focal_amplification_length_shape_2 = prob_CN_focal_amplification_length_shape_2,
    prob_CN_focal_deletion_length_shape_1 = prob_CN_focal_deletion_length_shape_1,
    prob_CN_focal_deletion_length_shape_2 = prob_CN_focal_deletion_length_shape_2,
    prob_CN_cnloh_interstitial_length = prob_CN_cnloh_interstitial_length,
    prob_CN_cnloh_terminal_length = prob_CN_cnloh_terminal_length,
    rate_driver = rate_driver,
    rate_passenger = rate_passenger,
    selection_model = selection_model,
    bound_driver = bound_driver,
    bound_average_ploidy = bound_average_ploidy,
    bound_homozygosity = bound_homozygosity,
    table_population_dynamics = table_population_dynamics,
    gc = gc,
    gc_slope = gc_slope,
    gc_int = gc_int,
    sigma1 = sigma1,
    num_reads = num_reads
)
```

## Selection variables

Depending on which selection model is specified in the variable `selection_model` to drive cancer evolution, we need to define additional variables.

### Chromosome arm selection model

If `selection_model` = `chrom-arm-selection` or `chrom-arm-and-driver-gene-selection`, then cancer is driven solely or partially by gains and losses of chromosome arms, based on their gene imbalances.

Five vectors in combination establish the chromosome arm selection rates. Given values at the same location in the vectors, `arm_s` is the selection rate for the arm with ID `arm_id`, which runs from starting bin `arm_start` to ending bin `arm_end` on chromosome `arm_chromosome`. The selection rate ranges from 0 to infinity. Arms with more Tumor Suppressor Genes than Oncogenes have selection rate less than 1, for which losses are advantageous and gains are deleterious. Arms with more Oncogenes than Tumor Suppressor Genes have selection rate higher than 1, for which gains are advantageous and losses are deleterious. The selective increases or decreases of the gains and losses of an arm depend on how far its selection rate is from 1.

```{r}
arm_id <- c(paste(model_variables$cn_info$Chromosome, "p", sep = ""), paste(model_variables$cn_info$Chromosome, "q", sep = ""))
arm_chromosome <- rep(model_variables$cn_info$Chromosome, 2)
arm_start <- c(rep(1, length(model_variables$cn_info$Chromosome)), model_variables$cn_info$Centromere_location + 1)
arm_end <- c(model_variables$cn_info$Centromere_location, model_variables$cn_info$Bin_count)
arm_s <- rep(1, length(arm_id))
arm_s[which(arm_id == "1p")] <- 1 + 0.05
arm_s[which(arm_id == "1q")] <- 1 + 0.065
arm_s[which(arm_id == "2p")] <- 1 + 0.06
arm_s[which(arm_id == "2q")] <- 1 + 0.05
arm_s[which(arm_id == "3p")] <- 1 + 0.02
arm_s[which(arm_id == "3q")] <- 1 + 0.095
arm_s[which(arm_id == "4p")] <- 1 - 0.013
arm_s[which(arm_id == "4q")] <- 1 - 0.016
arm_s[which(arm_id == "5p")] <- 1 + 0.18
arm_s[which(arm_id == "5q")] <- 1 - 0.1
arm_s[which(arm_id == "6p")] <- 1 + 0.2
arm_s[which(arm_id == "6q")] <- 1 - 0.17
arm_s[which(arm_id == "7p")] <- 1 + 0.02
arm_s[which(arm_id == "7q")] <- 1 + 0.1
arm_s[which(arm_id == "8p")] <- 1 - 0.14
arm_s[which(arm_id == "8q")] <- 1 + 0.2
arm_s[which(arm_id == "9p")] <- 1 + 0.022
arm_s[which(arm_id == "9q")] <- 1 + 0.022
arm_s[which(arm_id == "10p")] <- 1 + 0.03
arm_s[which(arm_id == "10q")] <- 1 + 0.035
arm_s[which(arm_id == "11p")] <- 1 - 0.15
arm_s[which(arm_id == "11q")] <- 1 + 0.13
arm_s[which(arm_id == "12p")] <- 1 + 0.08
arm_s[which(arm_id == "12q")] <- 1 + 0.04
arm_s[which(arm_id == "13p")] <- 1 + 0.03
arm_s[which(arm_id == "13q")] <- 1 + 0.022
arm_s[which(arm_id == "14p")] <- 1 + 0.022
arm_s[which(arm_id == "14q")] <- 1 + 0.016
arm_s[which(arm_id == "15p")] <- 1 + 0.02
arm_s[which(arm_id == "15q")] <- 1 + 0.01
arm_s[which(arm_id == "16p")] <- 1 + 0.01
arm_s[which(arm_id == "16q")] <- 1 - 0.08
arm_s[which(arm_id == "17p")] <- 1 - 0.07
arm_s[which(arm_id == "17q")] <- 1 + 0.01
arm_s[which(arm_id == "18p")] <- 1 - 0.04
arm_s[which(arm_id == "18q")] <- 1 - 0.03
arm_s[which(arm_id == "19p")] <- 1 + 0.06
arm_s[which(arm_id == "19q")] <- 1 + 0.06
arm_s[which(arm_id == "20p")] <- 1 + 0.05
arm_s[which(arm_id == "20q")] <- 1 + 0.06
arm_s[which(arm_id == "21p")] <- 1 - 0.22
arm_s[which(arm_id == "21q")] <- 1 + 0.08
arm_s[which(arm_id == "22p")] <- 1 - 0.02
arm_s[which(arm_id == "22q")] <- 1 - 0.02
arm_s[which(arm_id == "Xp")] <- 1 - 0.04
arm_s[which(arm_id == "Xq")] <- 1 - 0.04
```

The five vectors are combined into one data frame describing the chromosome arm selection model:

```{r}
table_arm_selection_rates <- data.frame(Arm_ID = arm_id, Chromosome = arm_chromosome, Bin_start = arm_start, Bin_end = arm_end, s_rate = arm_s)
```

### Driver gene selection model

If `selection_model` = `driver-gene-selection` or `chrom-arm-and-driver-gene-selection`, then cancer is driven solely or partially by gains, losses and mutations of driver genes.

Five vectors in combination establish the driver gene selection rates. Given values at the same location in the vectors, the gene with ID `gene_id`, which functions as `gene_role` (either `TSG` for Tumor Suppressor Genes or `ONCOGENE` for Oncogenes) at bin `gene_bin` on chromosome `gene_chromosome`, has selection rate `gene_s`. Similar to the chromosome arm selection model, here the driver gene's selection rate also ranges from 0 to infinity. However, which CNA events are selective or deleterious for a gene depends also on its role. For a Tumor Suppressor Gene:
- Amplification of the wild-type alleles is deleterious.
- Deletion of the wild-type alleles is advantageous.
- Amplification and deletion of the mutant alleles are neutral.
- Mutation, i.e. a wild-type allele changes to mutant, is advantageous.
On the other hand, for an Oncogene:
- Amplification of the wild-type allele or the mutant allele is advantageous.
- Deletion of the wild-type allele or the mutant allele is deleterious.
- Mutation, i.e. a wild-type allele changes to mutant, is advantageous.
The selective increases or decreases resulting from gain/loss or mutation of a gene (making the cell more advantageous or deleterious) depend on how far its selection rate is from 1.

```{r}
library(readxl)
driver_gene_list <- read_excel("HGSOC_driver_genes.xlsx")
gene_id <- driver_gene_list$Gene_ID
gene_role <- driver_gene_list$Gene_role
gene_chromosome <- driver_gene_list$Chromosome
gene_bin <- round(driver_gene_list$Start / CN_bin_length)
gene_s <- rep(1, length(gene_id))
```

The five vectors are combined into one data frame describing the driver gene selection model:

```{r}
table_gene_selection_rates <- data.frame(Gene_ID = gene_id, Gene_role = gene_role, s_rate = gene_s, Chromosome = gene_chromosome, Bin = gene_bin)
```

### Update the model variables with the selection model

After the table(s) are finished, we can update `model_variables` with the variables for the selection model. Include only the tables required for the selected selection model:

```{r}
model_variables <- BUILD_driver_library(
    model_variables = model_variables,
    table_arm_selection_rates = table_arm_selection_rates,
    table_gene_selection_rates = table_gene_selection_rates
)
```

## Initial cell population

We now specify the initial cell population. Here we assume that the initial state consists of one clone, where `cell_count` is its cell count. The variable `CN_matrix` specifies the clone's CN profile, here assumed to be normal diploid female cells. The variable `drivers` defines the existing driver mutations in the clone, here assumed to be none.

```{r}
cell_count <- 20
CN_matrix <- BUILD_cn_normal_XX(model_variables$cn_info)
drivers <- list()
model_variables <- BUILD_initial_population(
    model_variables = model_variables,
    cell_count = cell_count,
    CN_matrix = CN_matrix,
    drivers = drivers
)
```

If the initial cell population consists of multiple clones, the function `BUILD_initial_population` can be repeated for each distinct clone with different `cell_count`, `CN_matrix` and `drivers`.

## Save the input files

The final step of model variable preparation is using the function `SAVE_model_variables` to save the variables defined thus far in csv files. The variable `model_name` is incorporated into the csv files' names, and the simulator will look up files starting with this string to set up the simulations. Therefore, if different models are simulated in the same folder, they should be saved with different `model_name` so as not to overwrite older models.

```{r}
model_name <- "EXPERIMENT"
SAVE_model_variables(model_name = model_name, model_variables = model_variables)
```

# Run the simulator

The function `simulator_full_program` produces simulations according to the model variables listed in the csv files resulting from the previous section.

There are several options for conditioning on the simulations or requesting specific results:
- `model`: Prefix of the csv input files. This should be the same as `model_name` from the previous section.
- `n_simulations`: Number of simulations requested.
- `compute_parallel`: Simulations are produced sequentially if `FALSE`, or in parallel if `TRUE`. Default is `FALSE`.
- `n_cores`: Number of computer CPUs to use to produce simulations in parallel (therefore only applied when `compute_parallel`=`TRUE`). If `n_cores` is not specified when `compute_parallel`=`TRUE`, the algorithm uses all available CPU cores except one.
- `seed`: Seed to produce replicable stochastic simulations. Only applicable when `compute_parallel`=`FALSE`.
- `report_progress`: The simulator prints updates of the progress if set to `TRUE`.
- `save_simulation`: All output variables from each simulation are saved in separate `rda` files if set to `TRUE`. Default is `TRUE`.
- `output_variables`: Vector of specific output variables from each simulation to return in the list format in R. Default is `NULL`, in which case no variable is returned.
- `folder_workplace`: Name of folder in the current directory to store output files from the simulations. If the folder does not exist, it will be created. Default is `NULL`, in which case files are saved within the current directory.
- `R_libPaths`: Name of folder where required R libraries are stored. Default is `NULL`, in which case the simulator assumes relevent R libraries are automatically usable.
- `n_clones_min`: Lower limit for number of clones at the ending time point for simulations to be accepted. Default is `0`.
- `n_clones_max`: Upper limit for number of clones at the ending time point for simulations to be accepted. Default is `Inf`.
- `neutral_variations`: Whether neutral CNAs are simulated on top of the selective CNAs.
- `save_newick_tree`: If `TRUE`, the phylogeny of sampled cells from each simulation is saved in the Newick format. Default is `FALSE`.
- `save_cn_profile`: If `TRUE`, the CN profiles of sampled cells from each simulation are saved in a csv file. Default is `FALSE`.
- `format_cn_profile`: If `long` when `save_cn_profile`=`TRUE`, the CN profiles are saved in the long format (subsequent cells are appended by row). If `wide` when `save_cn_profile`=`TRUE`, the CN profiles are saved in the wide format (each cell occupies a column). If `both` when `save_cn_profile`=`TRUE`, the CN profiles are saved in both formats (resulting in two csv files per simulation). Default is `long`.
- `save_cn_clones`: If `TRUE`, the assignment of which cell belongs in which clone is saved in a csv file. Default is `FALSE`.
- `internal_nodes_cn_info`: If `TRUE` when `save_cn_profile`=`TRUE`, the CN profiles of both the sampled cells and the internal nodes of their phylogeny are saved in the requested format(s). The internal node labels correspond to those in the Newick tree if `save_newick_tree`=`TRUE`. Default is `FALSE`.
- `model_readcount`: If `TRUE`, noisy readcounts are simulated from each sampled cell's CN profile and saved in a csv file. Default is `FALSE`.
- `model_readcount_base`: If `truth` when `model_readcount`=`TRUE`, noisy readcounts are simulated from the CN profile without neutral variations. If `neuvar` when `model_readcount`=`TRUE`, noisy readcounts are simulated from the CN profile with neutral variations. Both are simulated and saved in separate csv files if `model_readcount_base`=`all` when `model_readcount`=`TRUE`. Default is `all`.
- `HMM`: If `TRUE`, the cell's CN profiles are inferred back from the simulated noisy readcounts using HMMcopy. Default is `FALSE`.
- `HMM_containner`: Specifies which HMMcopy container is used when `HMM`=`TRUE`. Two available options are `singularity` and `docker`, which might have different efficiency.



- `pseudo_corrected_readcount`: if `TRUE`, the pseudo-corrected readcounts (= cell's HMM-inferred mean readcount X bin GC level) are computed and saved in a csv file. The specific data used depends on `model_readcount_base`. Default is `FALSE`.

```{r}
tmp <- simulator_full_program(
    model = model_name,
    n_simulations = 10,
    save_cn_profile = TRUE,
    save_cn_clones = TRUE,
    internal_nodes_cn_info = TRUE,
    report_progress = TRUE,
    seed = 10
)
```

A variety of plots from the simulation:

```{r}
plot_all(model = model_name,
    n_simulations = 10,
    compute_parallel = FALSE
)
```

---
title: "Introduction to CINner"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to CINner}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r setup}
library(CINner)
set.seed(1)
```

# Set up CINner

CINner requires a number of input parameters about the assumed characteristics of tumor growth. 
One easy method to load the parameters to `CINner` is by creating `model_variables`, 
a list containing relevant variables in a specific order.
Here we detail how to create `model_variables`.

## 1. General variables for every cell

### 1a. Tissue-specific and sampling variables

We first specify the cell lifespan, measured in days.
`cell_lifespan` is the mean of the exponentially distributed lifetime of every cell during cancer evolution, 
independent of their particular cellular profiles.

```{r}
cell_lifespan <- 30
```

Next, we specify the time points at the beginning and the end of each simulation. 
The unit can be `day`, `week` (= 7 days), `month` (= 30 days) or `year` (= 365 days). 
The unit for `T_0` and `T_end` should be consistent.

```{r}
T_0 <- list(0, "year")
T_end <- list(80, "year")
```

`Table_sample` details the time point that the DNA sample is taken (in the same unit as `T_0` and `T_end`), 
how many cells are in the sample, and the sample's ID.
The following code specifies that the sample in each CINner simulation
is labeled "SA01" and consists of 300 cells, taken at 80 years.

```{r}
Table_sample <- data.frame(Sample_ID = "SA01", Cell_count = 300, Age_sample = 80)
```

CINner's efficiency is based partially on its use of the tau-leaping algorithm, 
instead of the exact Gillespie algorithm. 
As such, it requires a suggested `T_tau_step`.
Each CINner result then simulates the cell population starting from `T_0` at time points `T_0 + T_tau_step`, `T_0 + 2 * T_tau_step`, ..., 
until it reaches `T_end`.
If not specified, `T_tau_step` is automatically set to be half of `cell_lifespan`. 
High time steps will lead to decreased simulation run time, but the simulations might not be statistically accurate.
Low time steps will lead to longer run time, but the simulations will be more reliable.

```{r}
T_tau_step <- cell_lifespan / 2
```

To speed up the simulations and in accordance with currently available DNA data, 
the genome is divided into bins of equal lengths (measured in number of nucleotides).
The CN profile of each cell is represented as a vector, consisting of the CN of each bin.
If not specified, `CN_bin_length` is automatically set to 500,000 nucleotides.

```{r}
CN_bin_length <- 500000
```

Three selection models are included in `CINner`:

- `chrom-arm-selection` models the selection for gains and losses of chromosome arms, depending on their genetic imbalances.
- `driver-gene-selection` models the selection for gains, losses and mutations of specific driver genes.
- `chrom-arm-and-driver-gene-selection` combines `chrom-arm-selection` and `driver-gene-selection` into a hybrid model, where cancer is driven both by large-scale genetic imbalance at whole-chromosome and chromosome-arm level and focal events targeting specific genes.

```{r}
selection_model <- "chrom-arm-and-driver-gene-selection"
```
Each selection model may require additional variables, which will be detailed in the following sections.

### 1b. Occurence rates and length distributions of copy number aberrations (CNAs)

For `selection_model` = `chrom-arm-selection` or `chrom-arm-and-driver-gene-selection`, we need to specify the probabilities that each CNA mechanism occurs in a mitotic division.
These events have an impact on the fitness of the progeny cells and therefore the selection landscape.
There are three large-scale CNA mechanisms:

- Whole Genome Duplication (WGD) results in one progeny cell with double the genomic material of the parent cell.
- Missegregation targets a uniformly chosen chromosome strand, which is then gained in one progeny cell and lost in the other.
- The same occurs for chromosome-arm missegregation, but only for one of the chromosome's arms (selected with equal probabilities).

The regional events target a randomly chosen region in a uniformly selected chromosome arm in one of the progeny cells. 
All of these events require additional parameters for the region length distributions, to be discussed next. 
There are four regional CNA mechanisms:

- Focal amplification and deletion duplicate or delete the region, respectively.
- Interstitial and terminal copy-neutral loss of heterozygosity (CNLOH) replace all alleles within the region across chromosome strands with an allele chosen at random. 
Interstitial CNLOH can occur anywhere in the arm, but terminal CNLOH has to occur at the chromosome's end.

```{r}
prob_CN_whole_genome_duplication <- 0.5e-4
prob_CN_missegregation <- 2e-4
prob_CN_chrom_arm_missegregation <- 2e-4
prob_CN_focal_amplification <- 2e-4
prob_CN_focal_deletion <- 2e-4
prob_CN_cnloh_interstitial <- 0
prob_CN_cnloh_terminal <- 0
```

In specific applications, we might also consider neutral versions of the aforementioned CNA mechanisms.
These events change the CN profiles of the progeny cells without affecting their fitness.
The rules dictating how the progeny cells' CN profiles change as a result of neutral CNAs are similar to the selective CNA mechanisms above,
including the additional parameters specifying the region length distributions of the regional CNA events.

```{r}
prob_neutral_CN_whole_genome_duplication <- 0
prob_neutral_CN_missegregation <- 0
prob_neutral_CN_chrom_arm_missegregation <- 0
prob_neutral_CN_focal_amplification <- 0
prob_neutral_CN_focal_deletion <- 0
prob_neutral_CN_cnloh_interstitial <- 0
prob_neutral_CN_cnloh_terminal <- 0
```

We now specify the parameters for the region length distributions of the regional CNA mechanisms.
For a given regional CNA mechanism `X` (= `CN_focal_amplification_length`, `CN_focal_deletion_length`, `CN_cnloh_interstitial_length`, or `CN_cnloh_terminal_length`), we can choose between two distributions:

- `model_X` = `geom`: the targeted region length is geometrically distributed, with the rate given by another parameter `prob_X` (unit is bin counts).
- `model_X` = `beta`: the ratio of the targeted region length over the chromosome arm follows the Beta distribution.
This requires two parameters for the Beta distribution, given by `prob_X_shape_1` and `prob_X_shape_2`.

```{r}
model_CN_focal_amplification_length <- "geom"
prob_CN_focal_amplification_length <- 10
model_CN_focal_deletion_length <- "beta"
prob_CN_focal_deletion_length_shape_1 <- 1
prob_CN_focal_deletion_length_shape_2 <- 7
```

### 1c. Occurence rate of driver and passenger mutations

For `selection_model` = `driver-gene-selection` or `chrom-arm-and-driver-gene-selection`, we need to specify the rate of driver mutations (per nucleotide per division).
If a driver mutation occurs, the gene to be mutated is chosen from an input list of driver genes (to be discussed next), excluding the genes already mutated in the cell. 
A cell's fitness increases with the number of driver mutations it has acquired.

```{r}
rate_driver <- 0
```

The rate of passenger mutations is likewise per nucleotide per division. However, passenger mutations do not change the cell's fitness.

```{r}
rate_passenger <- 1e-11
```

### 1d. Viability conditions

Cells increase their fitness by acquiring favorable CNAs and driver mutations. 
However, they are also subject to viability conditions. 
If it violates any of these conditions, a cell is deemed unviable and its fitness is set to 0, therefore will die:

- `bound_driver` is the upper bound on how many driver mutations the cell has acquired.
- `bound_average_ploidy` is the upper bound on the ploidy (i.e. average CN among all bins) of the cell.
- `bound_maximum_CN` is the upper bound on the CN in any bin in the cell.
- `bound_homozygosity` is the upper bound on the bin count with homozygosity (i.e. bins with CN=0).

```{r}
bound_driver <- 3
bound_average_ploidy <- 4.5
bound_maximum_CN <- 8
bound_homozygosity <- 0
```
### 1e. Population dynamics

CINner simulations are designed to follow any population dynamic (limited by how fast the cells can divide or die, defined by their lifespan). 
The dataframe `table_population_dynamics` lists the expected total cell counts at corresponding time points.
The expected population size in the CINner simulations at any time point is interpolated from the two nearest time points in this variable.

Here, we expect the cell population to follow a logistic expansion, growing from 20 cells at `T_0` to 10000 cells at `T_end`, with the midpoint at 20 years.

```{r}
vec_time <- T_0[[1]]:T_end[[1]]
vec_cell_count <- 10000 / (1 + exp(-0.3 * (vec_time - 20)))
table_population_dynamics <- cbind(vec_time, vec_cell_count)
```

### 1f. Initiate CINner model variables

Finally, we use function `BUILD_general_variables` to initiate `model_variables`, a list object containing all variables described thus far:

```{r}
model_variables <- BUILD_general_variables(
    cell_lifespan = cell_lifespan,
    T_0 = T_0, T_end = T_end, T_tau_step = T_tau_step,
    Table_sample = Table_sample,
    CN_bin_length = CN_bin_length,
    prob_CN_whole_genome_duplication = prob_CN_whole_genome_duplication,
    prob_CN_missegregation = prob_CN_missegregation,
    prob_CN_chrom_arm_missegregation = prob_CN_chrom_arm_missegregation,
    prob_CN_focal_amplification = prob_CN_focal_amplification,
    prob_CN_focal_deletion = prob_CN_focal_deletion,
    prob_CN_cnloh_interstitial = prob_CN_cnloh_interstitial,
    prob_CN_cnloh_terminal = prob_CN_cnloh_terminal,
    prob_neutral_CN_whole_genome_duplication = prob_neutral_CN_whole_genome_duplication,
    prob_neutral_CN_missegregation = prob_neutral_CN_missegregation,
    prob_neutral_CN_chrom_arm_missegregation = prob_neutral_CN_chrom_arm_missegregation,
    prob_neutral_CN_focal_amplification = prob_neutral_CN_focal_amplification,
    prob_neutral_CN_focal_deletion = prob_neutral_CN_focal_deletion,
    prob_neutral_CN_cnloh_interstitial = prob_neutral_CN_cnloh_interstitial,
    prob_neutral_CN_cnloh_terminal = prob_neutral_CN_cnloh_terminal,
    model_CN_focal_amplification_length = model_CN_focal_amplification_length,
    model_CN_focal_deletion_length = model_CN_focal_deletion_length,
    prob_CN_focal_amplification_length = prob_CN_focal_amplification_length,
    prob_CN_focal_deletion_length_shape_1 = prob_CN_focal_deletion_length_shape_1,
    prob_CN_focal_deletion_length_shape_2 = prob_CN_focal_deletion_length_shape_2,
    rate_driver = rate_driver,
    rate_passenger = rate_passenger,
    selection_model = selection_model,
    bound_driver = bound_driver,
    bound_average_ploidy = bound_average_ploidy,
    bound_homozygosity = bound_homozygosity,
    table_population_dynamics = table_population_dynamics
)
```
## 2. Selection rates

Depending on which selection model is specified in the variable `selection_model` to drive cancer evolution, we need to define the selection rates of each chromosome arm and/or each driver gene, 
which then define a cell's fitness as it acquires new CNAs and/or driver mutations.

### 2a. Chromosome arm selection rates

If `selection_model` = `chrom-arm-selection` or `chrom-arm-and-driver-gene-selection`, then cancer is driven solely or partially by gains and losses of chromosome arms, based on their gene imbalances.

Each row in `table_arm_selection_rates` details the information for one chromosome arm.
Its ID is listed in column `Arm_ID`, and its location is recorded in columns `Chromosome`, `Bin_start` and `Bin_end`.
Its selection rate is specified in column `s_rate` as a positive number.
Arms with more Tumor Suppressor Genes than Oncogenes have selection rate less than 1, for which losses are advantageous and gains are deleterious. 
Arms with more Oncogenes than Tumor Suppressor Genes have selection rate higher than 1, for which gains are advantageous and losses are deleterious. 
The strength of the selection force depends on the distance between the selection rate to 1:
chromosome arms with very small or very large selection rates are strongly selected for, and chromosome arms with selection rates very close to 1 are essentially neutral.

```{r}
Arm_ID <- c(
    paste(model_variables$cn_info$Chromosome, "p", sep = ""),
    paste(model_variables$cn_info$Chromosome, "q", sep = "")
)
Chromosome <- rep(model_variables$cn_info$Chromosome, 2)
Bin_start <- c(
    rep(1, length(model_variables$cn_info$Chromosome)),
    model_variables$cn_info$Centromere_location + 1
)
Bin_end <- c(
    model_variables$cn_info$Centromere_location,
    model_variables$cn_info$Bin_count
)
s_rate <- runif(length(Arm_ID), 1 / 1.2, 1.2)
table_arm_selection_rates <- data.frame(
    Arm_ID = Arm_ID,
    Chromosome = Chromosome,
    Bin_start = Bin_start,
    Bin_end = Bin_end,
    s_rate = s_rate
)
```

### 2b. Driver gene selection rates

If `selection_model` = `driver-gene-selection` or `chrom-arm-and-driver-gene-selection`, then cancer is driven solely or partially by gains, losses and mutations of driver genes.

Each row in `table_gene_selection_rates` details the information for one driver gene.
Its name is listed in column `Gene_ID`, and its location is recorded in columns `Chromosome` and `Bin`.
The gene's function as cancer driver is specified in column `Gene_role` (either `TSG` for Tumor Suppressor Genes or `ONCOGENE` for Oncogenes; other functions or dual roles are not currently supported), and its (positive) selection rate is in column `s_rate`.

The impact of CNA events on the cell's fitness depends on the mutated gene's function.
For a Tumor Suppressor Gene:

- Deletion of the wild-type alleles is advantageous.
- Amplification of the wild-type alleles is deleterious.
- Deletion of the mutant alleles is neutral.
- Mutation and amplification of the mutant alleles are advantageous.

On the other hand, for an Oncogene:

- Amplification of the wild-type or mutant allele is advantageous.
- Deletion of the wild-type allele or the mutant allele is deleterious.
- Mutation is advantageous.

Similar to the chromosome arm model, the strength of the selection force depends on the distance between the selection rate to 1.

```{r}
table_gene_selection_rates <- data.frame(
    Gene_ID = c("Driver_1", "Driver_2", "Driver_3"),
    Gene_role = c("TSG", "ONCOGENE", "TSG"),
    s_rate = c(0.8, 1.2, 0.9),
    Chromosome = c(1, 2, 3),
    Bin = c(10, 20, 30)
)
```

### 2c. Update CINner model variables

We now update `model_variables` to include the selection rates with function `BUILD_driver_library`.
Only the relevant selection rate dataframes should be included.

```{r}
model_variables <- BUILD_driver_library(
    model_variables = model_variables,
    table_arm_selection_rates = table_arm_selection_rates,
    table_gene_selection_rates = table_gene_selection_rates
)
```

## 3. Initial cell population

We now specify the initial cell population. 
Each clone in this population is described by its CN profile and list of driver mutations.

The variable `CN_matrix` specifies the clone's CN profile, consisting of 5 columns: `Chromosome`, `Strand`, `Bin_start`, `Bin_end`, and `Allele`.
For convenience, we can use function `BUILD_cn_normal_autosomes` to build a normal genome consisting only of autosomes (chromosomes 1 to 22, each with 2 alleles A and B),
or `BUILD_cn_normal_XX` to build a normal female genome (chromosomes 1 to 22 and X, each with 2 alleles A and B),
or `BUILD_cn_normal_XY` to build a normal male genome (chromosome 1 to 22, each with 2 alleles A and B; and chromosomes X and Y, each with 1 allele A).

```{r}
CN_matrix <- BUILD_cn_normal_autosomes(model_variables$cn_info)
```

The variable `drivers` lists the driver mutations that are pre-existing in the clone.

```{r}
drivers <- list("Driver_1")
```

To add this clone to the initial cell population, we use function `BUILD_initial_population` to update `model_variables`.
Beside `CN_matrix` and `drivers`, we also need to specify its `cell_count`.

```{r}
model_variables <- BUILD_initial_population(
    model_variables = model_variables,
    cell_count = 20,
    CN_matrix = CN_matrix,
    drivers = list()
)
```

If the initial cell population consists of multiple clones, the function `BUILD_initial_population` can be repeated for each distinct clone with different `cell_count`, `CN_matrix` and `drivers`.

## 4. Save CINner's model parameters
